'use strict';
const Promisie = require('promisie');
const periodic = require('periodicjs');
const fs = require('fs-extra');
const path = require('path');
const usecroncheckfile = path.resolve(__dirname, '../../../content/files/croncheck.json');
const parallel = Promisie.promisify(require('async').parallel);
const cronPath = path.resolve(__dirname, '../../../../content/files/crons');
const executeProcess = require('child_process').exec;
const spawnProcess = require('child_process').spawn;
const crypto = require('crypto');
const CoreController = periodic.core.controller;
const cron_lib = require('../lib/crons');
const downloadRemoteFiles = cron_lib.downloadRemoteFiles;
const pemfile = fs.readFileSync(path.join(periodic.config.app_root, 'otherdocs/pf-ils.pem')).toString();
const logger = periodic.logger;
const digest = cron_lib.digestCrons;
const themeName = periodic.settings.theme;
const helpers = require('../utilities').helper;

var Cron,
	Asset,
	assetController,
	appSettings,
	appenvironment,
	CoreUtilities,
	cloudUploads

var setCronFilePath = function (req, res, next) {
	req.localuploadpath = cronPath;
	req.body['existing-file-name'] = true;
	req.controllerData = req.controllerData || {};
	req.controllerData.encryptfiles = true;
	next();
};

/**
 * Utility function for generating a file signature
 * @param  {Object}   options Options for the function
 * @param {string} options.filePath Path to the file that the signature is for
 * @param {string} options.encoding Encoding of the file that the signature is being generated for
 * @param {string} options.file File data that is passed through to the callback function
 * @param  {Function} cb      Callback function
 */
var createFileSignatures = function (options, cb) {
	try {
		Promisie.promisify(fs.readFile)(options.filePath, options.encoding || 'utf8')
			.then(filedata => {
				let signData = new Buffer(filedata.trim()).toString('base64');
				let sign = crypto.createSign('RSA-SHA256');
				sign.update(signData);
				//pemfile is a .pem file used in generating the signature that is read at initialization and held in memory
				let signature = sign.sign(pemfile, 'hex');
				cb(null, {
					file: options.file,
					signature: signature
				});
			}, e => {
				cb(e);
			});
	}
	catch (e) {
		cb(e);
	}
};

/**
 * Creates periodic cron objects from assets
 * @param  {Object} req Express request object
 * @param {Array} req.controllerData.files An array of periodic file assets generated by the asset controller
 * @param {string} req.body.interval The interval at which the cron should be run
 * @param  {Object} res Express response object
 */
var createCrons = function (req, res, next) {
	// let CoreController = periodic.core.controller;
	try {
		let files = (Array.isArray(req.controllerData.files)) ? req.controllerData.files : [req.controllerData.files];
		//Tests that files are a javascript mimetype
		const jsMimeTest = function (mime) {
			return (mime === 'application/javascript' || mime === 'text/javascript' || mime === 'application/x-javascript');
		};
		let javascriptFiles = files.filter(file => jsMimeTest(file.mimetype));
		if (javascriptFiles.length) {
			//Converts asset data into an object that is compatible with downloadRemoteFiles function
			let filesForDownload = javascriptFiles.map(filedata => {
				return {
					locationtype: 'amazon',
					asset: filedata
				};
			});
			let options = {req, res};
			downloadRemoteFiles(filesForDownload, options)
				.then(() => {
					//Iterates through files returing the file and its signature
					let signatures = javascriptFiles.map(file => {
						return Promisie.promisify(createFileSignatures)({
							filePath: path.join(cronPath, file.filename),
							file: file
						});
					});
					return Promise.all(signatures);
				})
				.then(filedatas => {
					const Asset = periodic.datas.get('standard_asset');
					//Iterates through files finding corresponding assets and returns and array of cron mongoose schema compatible objects
					let readytocreate = filedatas.map(filedata => {
						return Promise.resolve(Asset.load({
							query: { 'attributes.periodicFilename': filedata.file.name }
						})).then(associatedAsset => {
							return {
								title: filedata.file.filename,
								name: filedata.file.original_filename,
								author: (req.user && typeof req.user === 'object') ? req.user.email : 'cron',
								content: 'cron',
								asset: associatedAsset._id,
								asset_signature: filedata.signature,
								cron_interval: req.body.cron_interval || '00 00 00 * * *',
								runtime_options: JSON.parse(req.body.runtime_options || '{}'),
								theme: (typeof themeName === 'string') ? themeName : undefined
							};
						});
					});
					return Promise.all(readytocreate);
				})
				.then(crons => {
					const Cron = periodic.datas.get('standard_cron');
					let createdCrons = crons.map(_cron => {
						return Cron.create({
							newdoc: _cron
						});
						// return CoreController.createModelPromisified({
						// 	model: Cron,
						// 	newdoc: _cron
						// });
					});
					return Promise.all(createdCrons);
				})
				.then(crons => {
					//Removes temporary cron files from cron directory
					let removed = crons.map(cron => {
						return Promisie.promisify(fs.remove)(path.join(cronPath, cron.title));
					});
					return Promise.all(removed)
						.then(() => crons);
				})
				.then(crons => {
					logger.silly('created crons', crons);
					//checks if croncheck file exists and runs digest function if it is
					if (periodic.settings.application.cron_check_file_enabled) {
						Promisie.promisify(digest)(null)
							.then(() => {
								return crons;
							})
							.catch(e => {
								logger.silly('Dont use crons', e);
								return crons;
							});
					}
					else {
						return crons;
					}
				})
				.then(crons => {
					next();
					// res.send({
					// 	result: 'success',
					// 	data: {
					// 		crons: crons
					// 	}
					// });
				})
				.catch(e => {
					CoreController.handleDocumentQueryErrorResponse({
						err: e,
						res: res,
						req: req
					});
				});
		}
		else {
			CoreController.handleDocumentQueryErrorResponse({
				err: 'No application/javascript type files were set for upload',
				res: res,
				req: req
			});
		}
	}
	catch (e) {
		CoreController.handleDocumentQueryErrorResponse({
			err: e,
			res: res,
			req: req
		});
	}
};

var deleteCron = function (req, res) {
	try {
		var options = {
			model: Cron,
			population: 'asset',
			docid: req.params.id
		};
		CoreController.loadModelPromisified(options)
			.then(cron => {
				return parallel({
						delete_cron: function (cb) {
							CoreController.deleteModelPromisified({
									model: Cron,
									deleteid: cron._id
								})
								.then(() => {
									cb(null, 'deleted cron');
								}, cb);
						},
						delete_asset: function (cb) {
							CoreController.deleteModelPromisified({
									model: Asset,
									deleteid: cron.asset._id
								})
								.then(() => {
									cb(null, 'deleted asset');
								}, cb);

						},
						delete_remote_file: function (cb) {
							let asset = cron.asset;
							let cloudClient = cloudUploads.cloudstorageclient();
							cloudClient.removeFile(asset.attributes.cloudcontainername, asset.attributes.cloudfilepath, cb);
						},
						delete_local_file: function (cb) {
							let filePath = path.join(cronPath, cron.asset.attributes.periodicFilename);
							Promisie.promisify(fs.stat)(filePath)
								.then(() => {
									fs.remove(filePath, cb);
								}, e => {
									logger.silly('There is not local file', e);
									cb(null, null);
								});
						}
					})
					.then(() => cron);
			})
			.then(cron => {
				let deletedCron = [{
					id: cron._id,
					status: false
				}];
				return Promisie.promisify(digest)(deletedCron);
			})
			.then(() => {
				res.send({
					result: 'success',
					data: {
						message: 'Cron was deleted and stopped'
					}
				});
			})
			.catch(e => {
				CoreController.handleDocumentQueryErrorResponse({
					err: e,
					res: res,
					req: req
				});
			});
	}
	catch (e) {
		CoreController.handleDocumentQueryErrorResponse({
			err: e,
			res: res,
			req: req
		});
	}
};

var runCron = function (req, res, next) {
	let cron = req.controllerData.cron.toJSON();
	let downloadOptions = [cron];
	downloadRemoteFiles(downloadOptions)
		.then(() => {
			let periodicFilename = cron.asset.attributes.periodicFilename;
			let fnPath = path.join(cronPath, periodicFilename.replace(/\.enc/gi, ''));
			require(fnPath).script(periodic)(Object.assign({}, cron.runtime_options));
			return new Promise(resolve => {
				setTimeout(function () {
					resolve();
				}, 10000);
			});
		})
		.then(() => {
			let cronMap = cron_lib.getCronMap();
			if (Object.keys(cronMap).indexOf(cron._id.toString()) === -1) {
				return Promisie.promisify(fs.remove)(path.join(cronPath, cron.asset.attributes.periodicFilename));
			}
			else {
				return true;
			}
		})
		.then(() => {
			next();
			// res.send({
			// 	result: 'success',
			// 	data: {
			// 		message: `Finished running cron ${ cron._id }`
			// 	}
			// });
		})
		.catch(e => {
			CoreController.handleDocumentQueryErrorResponse({
				err: e,
				res: res,
				req: req
			});
		});
};

/**
 * Removes temporary file from content/files/crons directory if cron is not currently active
 * @param  {Object} cron Periodic cron object
 */
var removeNonActiveCronAfterProcess = function (cron) {
	try {
		let cronMap = cron_lib.getCronMap();
		let periodicFilename = cron.asset.attributes.periodicFilename;
		if (Object.keys(cronMap).indexOf(cron._id.toString()) === -1) {
			fs.remove(path.join(cronPath, periodicFilename.replace(/\.enc/gi, '')), function () {
				logger.silly('Removed temp cron file after validate');
			});
		}
	}
	catch (e) {
		logger.warn('Could not remove temp cron file after process', e);
	}
};

/**
 * Utility function for running validate_cron script in a child process
 * @param  {string} filePath The absolute path to the file being linted
 * @return {Object} returns a new Promise
 */
var lint = function (filePath) {
	return new Promise((resolve, reject) => {
		executeProcess(`node ${ path.join(__dirname, '../scripts/validate_cron.js') } --filePath ${ filePath }`, (err, stdout, stderr) => {
			if (stdout) {
				resolve(stdout);
			}
			else {
				reject(err || stderr);
			}
		});
	});
};

/**
 * Function that runs cron file validation and sends the results of the lint
 * @param  {Object} req Express request object
 * @param {Object} req.controllerData Data that has been appended to request object is previous middleware
 * @param {Object} req.controllerData.cron Mongo cron object
 * @param  {Object} res Express response object
 */
var validateCron = function (req, res) {
	try {
		let cron = req.controllerData.cron.toJSON();
		let lintPath = path.join(cronPath, cron.asset.attributes.periodicFilename);
		Promisie.promisify(fs.stat)(lintPath)
			.then(() => {
				return true;
			}, () => {
				return downloadRemoteFiles([cron]);
			})
			.then(() => lint(lintPath))
			.then(result => {
				res.send({
					result: 'success',
					data: result
				});
				removeNonActiveCronAfterProcess(cron);
			})
			.catch(e => {
				removeNonActiveCronAfterProcess(cron);
				CoreController.handleDocumentQueryErrorResponse({
					err: e,
					res: res,
					req: req
				});
			});
	}
	catch (e) {
		CoreController.handleDocumentQueryErrorResponse({
			err: e,
			res: res,
			req: req
		});
	}
};

/**
 * Executes child process which runs cron test file using mocha assumes that the test file is in the theme lib directory
 * @param  {string} filePath An absolute file path for the cron file
 * @return {Object}          returns a new Promise
 */
var testCron = function (filePath) {
	let cron = require(filePath);
	return new Promise((resolve, reject) => {
		try {
			if (!cron.test) {
				throw new Error('Cron does not have a defined test configuration');
			}
			else {
				let argv = [path.join(__dirname, '../scripts/mocha_cron.js'), '--fileName', path.join(path.join(__dirname, `../../../content/themes/${ appSettings.theme }/lib`), cron.test.fileName), '--modulePath', filePath];
				if (cron.test.options && typeof cron.test.options === 'object') {
					argv.push('--mochaOptions', JSON.stringify(cron.test.options));
				}
				let child = spawnProcess('node', argv, {
					stdio: ['ignore', 'pipe', 'pipe'],
					cwd: path.join(__dirname, '../../../')
				});
				let result;
				let error = '';
				child.stdout.on('data', d => {
					let data = d.toString();
					try {
						if (/^\{/.test(data)) {
							let parsed = JSON.parse(data);
							if (parsed.failures && parsed.passes) {
								result = parsed;
							}
						}
					}
					catch (e) {
						return;
					}
				});
				child.stderr.on('data', e => {
					error += e.toString();
				});
				child.on('exit', () => {
					if (result) {
						resolve(result);
					}
					else {
						reject(error);
					}
				});
			}
		}
		catch (e) {
			reject(e);
		}
	});
};

/**
 * Function that runs cron test spec and responds with the passing and failing cases
 * @param  {Object} req Express request object
 * @param {Object} req.controllerData.cron Periodic cron object
 * @param  {Object} res Express response object
 */
var mochaCron = function (req, res) {
	try {
		let cron = req.controllerData.cron.toJSON();
		let testPath = path.join(cronPath, cron.asset.attributes.periodicFilename);
		Promisie.promisify(fs.stat)(testPath)
			.then(() => {
				return true;
			}, () => {
				return downloadRemoteFiles([cron]);
			})
			.then(() => testCron(testPath))
			.then(testResult => {
				try {
					let response = {
						result: 'success',
						data: {}
					};
					if (typeof testResult === 'string') {
						throw new Error(`Error from child - ${ testResult }`);
					}
					if (testResult.stats && Number(testResult.stats.failures) > 0) {
						response.data.message = JSON.stringify(testResult);
					}
					else {
						response.data.message = 'Completed test spec with no failures';
					}
					logger.info(`${ cron.asset.attributes.periodicFilename } test results`, testResult);
					res.send(response);
					removeNonActiveCronAfterProcess(cron);
				}
				catch (e) {
					return Promise.reject(e);
				}
			})
			.catch(e => {
				removeNonActiveCronAfterProcess(cron);
				CoreController.handleDocumentQueryErrorResponse({
					err: e,
					res: res,
					req: req
				});
			});
	}
	catch (e) {
		CoreController.handleDocumentQueryErrorResponse({
			err: e,
			res: res,
			req: req
		});
	}
};

function handleAssetDownload(req, res, next) {
	try {
		req.controllerData = req.controllerData || {};
		if (req.controllerData && req.controllerData.decryptedFile) {
			req.controllerData.cron.attributes = req.controllerData.cron.attributes || {};
			req.controllerData.cron.attributes.templatehtml = req.controllerData.decryptedFile;
		}
		next();
	} catch(e) {
		logger.warn(`Error in handleAssetDownload: ${e}`);
	}
}

function findCron(req, res, next) {
	req.controllerData = req.controllerData || {};
	let Cron = periodic.datas.get('standard_cron');
	Cron.load({ query: { _id: req.params.id }})
	.then(cron => {
		req.controllerData.cron = cron;
		next();
	})
	.catch(e => {
		logger.warn('Error loading cron: ', e);
	})
}

function stageAssetDownload(req, res, next) {
	try {
		req.controllerData = req.controllerData || {};
		req.controllerData.storeDecryptedAsset = true;
		req.params.id = req.controllerData.cron.asset._id.toString();
		next();
	} catch (e) {
		logger.warn(`Error in stageAssetDownload: ${e}`);
	}
}

function stageAssetUpload(req, res, next) {
	try {

		req.controllerData = req.controllerData || {};
		let multipartdata = helpers.generateMultipartData({}, [{
			name: req.controllerData.cron.name,
			filename: req.controllerData.cron.asset.attributes.periodicFilename,
			data: req.body['attributes.templatehtml'],
		}])
		req.headers['Content-Type'] = `multipart/form-data; boundary=${ multipartdata.boundary }`;
		req.headers['content-type'] = `multipart/form-data; boundary=${ multipartdata.boundary }`;
		req.headers['Content-Length'] = Buffer.byteLength(multipartdata.formdata);
		req.headers['content-length'] = Buffer.byteLength(multipartdata.formdata);

		const reqBuffer = fs.createReadStream(Buffer.from(multipartdata.formdata));
		req = Object.assign({},req,reqBuffer);
		next();
	} catch (err) {
		next(err);
	}
}

function createTempAsset(req, res, next) {
	try {
		req.controllerData = req.controllerData || {};
		let filePath = path.join(cronPath, req.controllerData.cron.asset.attributes.periodicFilename.replace('.enc', ''));
		fs.outputFile(filePath, Buffer.from(req.body['attributes.templatehtml']), err => {
			if (err) {
				logger.warn(`Error in createTempAsset: ${e}`)
			}
		});
		next();
	} catch (err) {
		next(err);
	}
}

function stageMultipartData(req, res, next) {
	try {
		req.controllerData = req.controllerData || {};
		let multipartdata = helpers.generateMultipartData({}, [{
			name: req.controllerData.cron.name,
			filename: req.controllerData.cron.asset.attributes.original_filename,
			data: req.body['attributes.templatehtml'],
		}])
		helpers.uploadFileData(multipartdata);
		next();
	} catch (err) {
		next(err);
	}
}

function deleteTempAsset(req, res, next) {
	try {
		req.controllerData = req.controllerData || {};
		let filePath = path.join(cronPath, req.controllerData.cron.asset.attributes.periodicFilename.replace('.enc', ''));
		fs.remove(filePath, err => {
			if (err) {
				logger.warn(`Error in deleteTempAsset: ${e}`)
			}
		});
		next();
	} catch (err) {
		next(err);
	}
}

const handleResponseData = function (req, res) {
	req.controllerData = req.controllerData || {};
	delete req.controllerData.authorization_header;
	res.send((req.controllerData.useSuccessWrapper) ? {
		result: 'success',
		data: req.controllerData,
	} : req.controllerData);
};

/**
 * Middleware function that prepares update to crons active/inactive status
 * @param {Object}   req  Express request object
 * @param {Object} req.controllerData.cron Mongo cron object
 * @param {Object}   res  Express response object
 */
var setCronStatus = function (req, res, next) {
	req.body = req.controllerData.cron.toJSON();
	req.body.docid = req.controllerData.cron._id;
	req.body.active = !req.controllerData.cron.active;
	req.body._id = req.controllerData.cron._id;
	req.body.asset = req.controllerData.cron.asset._id;
	req.body.skip_xss = true;
	req.skipemptyvaluecheck = true;
	// delete req.body._id;
	next();
};

function sendMicroserviceResponseJSON(req, res) {
  if (req.controllerData) {
    res.status(200).json(req.controllerData);
  } else {
    res.status(500).send({ error: 'There is no data set for send', });
  }
};

var updateCronStatus = function (req, res) {
	try {
		let cronStatus = req.body.active;
		let Cron = periodic.datas.get('standard_cron');
		let options = {
			id: req.body._id,
			updatedoc: req.body,
			depopulate: false,
		}
		return Cron.update(options)
			.then(() => {
				let modifiedCron = [{
					id: req.controllerData.cron._id,
					status: req.body.active
				}];
				return Promisie.promisify(digest)(modifiedCron);
			})
			.then(() => {
				res.send({
					result: 'success',
					data: {
						message: `Cron ${ req.controllerData.cron._id } has ${ (cronStatus) ? 'started' : 'stopped' }`
					}
				});
			})
			.catch(e => {
				CoreController.handleDocumentQueryErrorResponse({
					err: e,
					res: res,
					req: req
				});
			});
	}
	catch (e) {
		CoreController.handleDocumentQueryErrorResponse({
			err: e,
			res: res,
			req: req
		});
	}
};

function stageFileUpload(req, res, next) {
  let reqBody = Object.assign({}, req.query, req.body);
  req.user = (req.user) ? req.user : { _id: req.body.user_id, };
  if (reqBody.applicant_guid) {
    req.localuploadpath = 'applicantdocs/'+reqBody.applicant_guid;
  }
  next();
}

function updateCron(req, res, next) {
	try {
		req.controllerData = req.controllerData || {};
		let file = req.body['attributes.templatehtml'];
		let Cron = periodic.datas.get('standard_cron');
		let signData = new Buffer(file.trim()).toString('base64');
		let sign = crypto.createSign('RSA-SHA256');
		sign.update(signData);
		let signature = sign.sign(pemfile, 'hex');

		Cron.load({ query: { _id: req.params.id }})
		.then(cron => {
			cron.interval = req.body.interval;
			cron.asset_signature = signature;
			cron.save();
			req.controllerData.cron = cron;
			next();
		})
		.catch(e => {
			logger.warn('Error loading cron: ', e);
		})
	} catch(e) {
		logger.warn(`Error in updateCron: ${e}`);
	}
}

function updateCronWithNewAsset(req, res, next) {
	try {
		req.controllerData = req.controllerData || {};
		let Cron = periodic.datas.get('standard_cron');
		Cron.load({ query: { name: req.controllerData.files[0].fieldname }})
		.then(cron => {
			cron.asset = req.controllerData.standard_asset[0]._id;
			cron.title = req.controllerData.standard_asset[0].attributes.periodicFilename.replace(/\.enc/gi, '');
			return cron.save(function (err, saved) {
				console.log('***************************');
				console.log({ saved });
				next();
			});
		})
		.catch(e => {
				logger.warn(`Error in updateCronWithNewAsset: ${e}`);
		})
	} catch(e) {
		logger.warn(`Error in updateCronWithNewAsset: ${e}`);
	}
}

function clearCronCache(req, res, next) {
  Object.keys(require.cache).forEach(key => {
    if (key.indexOf(cronPath) > -1) {
      delete require.cache[ key ];
    }
  });
  next();
}

function updateCronJob(req, res, next) {
	cron_lib.initializeCrons(null, function (err) {
		if (err) {
			logger.error('Could not start crons', err);
		} else {
			logger.silly('complete update');
		}
		next();
	});
}

module.exports = {
	clearCronCache,
	createTempAsset,
	deleteTempAsset,
	stageAssetDownload,
	stageAssetUpload,
	handleAssetDownload,
  handleResponseData,
	setCronFilePath,
	createCrons,
	findCron,
	mochaCron,
	validateCron,
	runCron,
	setCronStatus,
	sendMicroserviceResponseJSON,
	stageMultipartData,
	stageFileUpload,
	updateCronStatus,
	updateCron,
	updateCronWithNewAsset,
	updateCronJob,
};